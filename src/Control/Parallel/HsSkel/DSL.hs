{-# LANGUAGE GADTs #-}
{-# LANGUAGE Arrows #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# OPTIONS_HADDOCK show-extensions #-}

-- | This module defines the DSL to construct Streams and Skeletons.
module Control.Parallel.HsSkel.DSL (
    -- * Types
    Future(..),
    Skel(..),
    Stream(..),
    -- * Execution
    ExecutionContext(exec),
    -- * Skeleton Smart Constructors
    skSeq,
    SkParSupport(skPar),
    skSync,
    skMap,
    skRed,
    -- * Stream Smart Constructors
    StGenSupport(stGen),
    stMap,
    stChunk,
    stUnChunk,
    stStop,
    -- * Miscellaneous
    stFromList,
    skConst,
    skMapF,
    skPairF,
    skTraverseF,
    skDaC
) where

import Data.Traversable (Traversable)
import Data.Vector (Vector)
import Control.Arrow (Arrow(arr, first, second, (***)), ArrowChoice(left, right, (+++)), ArrowApply(app), returnA)
import Control.Category (Category, id, (.))
import Control.Concurrent.MVar (MVar)
import Control.DeepSeq (NFData)
import Prelude (Bool, Either, Int, Maybe(Just, Nothing), ($))


{- ================================================================== -}
{- ============================= Types ============================== -}
{- ================================================================== -}

-- | This type represents a computation that is running in background.
-- Is not possible to handle futures directly and you need to use them inside the Skeletons DSL.
newtype Future a = Future { mvar :: MVar a }


-- | This data type represents the core of the Skeleton DSL.
-- 
-- A Skeleton is an abstraction over functions that allows to create common solutions to common problems. A type of @Skel i o@ should be readed as "an Skeleton that takes a value of type @i@ and generate an output of type @o@".
-- 
-- For every data type constructor that does not exists an arrow notation equivalence, exists a function with the same signature and name, but with the first letter in lowercase.
--
-- The data type constructors are exposed to other modules only to allow the creation of multiple execution schedulers, but the design of the DSL is focused to take advantage of the expression power of the arrow extension.
-- 
-- If you are not developing a new execution scheduler, then will be better to you use the smart constructors function and the arrow notation instead of using directly the data type constructors. For ensure doing that, add an import to 'Control.Parallel.HsSkel' instead of 'Control.Parallel.HsSkel.DSL'.
-- 
-- The constructors used in the arrow notation are:
-- 
-- * 'SkSeq_' is the same that 'arr' of 'Arrow'.
-- * 'SkComp' is the same that '.' of 'Category'
-- * 'SkPair' is the same that '***' of 'Arrow'
-- * 'SkChoice' is the same that '+++' of 'ArrowChoice' and is used in the if statement on the arrow notation.
-- * 'SkApply' is the same that 'app' of 'ArrowApply' and is used with the -<< operator in the arrow notation.
data Skel i o where

    SkSeq    :: (NFData o) => (i -> o) -> Skel i o
    SkSeq_   :: (i -> o) -> Skel i o
    
    SkPar    :: Skel i o -> Skel i (Future o)
    SkSync   :: Skel (Future i) i
    SkComp   :: Skel x o -> Skel i x -> Skel i o
    SkPair   :: Skel i1 o1 -> Skel i2 o2 -> Skel (i1, i2) (o1, o2)

    SkMap    :: (Traversable t) => Skel i o -> Skel (t i) (t o)
    SkChoice :: Skel i o -> Skel i' o' -> Skel (Either i i') (Either o o')
    SkApply  :: Skel (Skel i o, i) o

    SkRed    :: Skel (o, i) o -> Stream i -> Skel o o
    

-- | A Stream is like a pipeline that receives a flow of data and each single data pass across multiple parallel stages.
-- 
-- Every stage of the pipeline will be executed in parallel and depends of the execution scheduler implement some communication between the stages in order to avoid one stage produce data more quickly that the other can process that data. 
--
-- The first stage of Streams will be generated by the 'StGen' constructor. This constructor is the link between the user code and the Stream world.
--
-- A Stream cannot be infinite and is the programmer that must ensure the end of the Stream. An Stream can be finished by returning Nothing in the function of 'StGen' or by adding an 'StStop' stage that returns true. See the doc of 'stGen' and 'stStop' for more details.
--
-- The Stream and Skel world are connected by the 'skRed' smart constructor, that is like a fold over the stream applying an accumulator function and returning the result inside a Skeleton.
data Stream d where
    StGen     :: NFData o => (i -> (Maybe (o, i))) -> i -> Stream o
    StMap     :: Skel i o -> Stream i -> Stream o
    StChunk   :: Int -> Stream i -> Stream (Vector i)
    StUnChunk :: Stream (Vector i) -> Stream i
    StStop    :: Skel (c, i) c -> c -> Skel c Bool -> Stream i -> Stream i


{- ================================================================== -}
{- ======================= Category and Arrow ======================= -}
{- ================================================================== -}

instance Category Skel where
    id  = SkSeq_ id
    (.) = SkComp

instance Arrow Skel where
    arr = SkSeq_
    first sk = sk `SkPair` id
    second sk = id `SkPair` sk
    (***) = SkPair
    --(&&&) sk1 sk2 = idem to default implementation.

instance ArrowChoice Skel where
    left sk = SkChoice sk id
    right sk = SkChoice id sk
    (+++) = SkChoice
    --(|||) sk1 sk2 = idem to default implementation.

instance ArrowApply Skel where
    app = SkApply


{- ================================================================== -}
{- ======================= Smart Constructors ======================= -}
{- ================================================================== -}

-- | Smart constructor for 'SkSeq'. This and 'arr' functions are the link between the user code and the Skeleton DSL.
-- 
-- This constructor creates an Skeleton that fully evaluates its output.
-- 
-- The main use of this constructor is for pass it to the 'skPar' and ensure that the code in the 'Future' fully evaluates the result.
skSeq :: (NFData o) => (i -> o) -- ^ A user defined function. 'NFData' is required for fully evaluates the output.
    -> Skel i o
skSeq = SkSeq

-- | Smart constructor for 'SkSync'.
--
-- This constructor blocks until the input Future is completed and is the only way to get off a Future.
skSync :: Skel (Future i) i
skSync = SkSync

-- | Smart constructor for 'SkMap'.
-- 
-- This constructor is like 'Functor.fmap' but inside the Skeleton DSL. It takes a 'Traversable' structure and apply the Skeleton parameter to each element in the structure.
skMap :: (Traversable t) => Skel i o -> Skel (t i) (t o)
skMap = SkMap

-- | Smart constructor for 'SkRed'.
--
-- This constructor takes an accumulative Skeleton and a Stream and creates an Skeleton that takes an initial value and applies the accumulative Skeleton to each values of the Stream, returning the accumulated value.
--
-- Is like a fold for Stream but inside of the Skeleton DSL.
skRed :: Skel (o, i) o -> Stream i -> Skel o o
skRed = SkRed

-- | Smart constructor for 'StMap'.
--
-- Takes a Skeleton and a Stream and returns a Stream with the same stages plus a new end stage that applies the Skeleton parameter to each value.
stMap :: Skel i o -> Stream i -> Stream o
stMap = StMap

-- | Smart constructor for 'StChunk'.
--
-- Takes a size and a Stream a returns a Stream with the same stages plus a new end stage that collect @size@ values and put them in a vector.
-- Is useful if the work for processing each single value for the next stages is lower than the framework overhead.
stChunk :: Int -> Stream i -> Stream (Vector i)
stChunk = StChunk

-- | Smart constructor for 'StUnChunk'.
--
-- Allows to get of a previous 'stChuck' application by adding a new end stage that takes a 'Vector' of values and put each single value in the stream.
stUnChunk :: Stream (Vector i) -> Stream i
stUnChunk = StUnChunk

-- | Smart constructor for 'StStop'.
--
-- This constructor allow to stop the Stream outside the generator function used in the 'stGen'.
-- 
-- Is useful for problems in which put the logic of stop the stream in the generator should be too complex. For example, generate a Stream with the first 50 fibonnacci prime numbers. Using this constructor is possible to create an Stream that the generator gives fibonnacci numbers, the next stage verifies if the number is prime, and the next stop stage verifies if we have already 50 primes numbers.
stStop :: Skel (c, i) c -> c -> Skel c Bool -> Stream i -> Stream i
stStop = StStop

-- | This class allows to use the same function name for create an Skeleton from a function or another Skeleton.
class SkParSupport a i o where
    -- | Smart constructor for 'SkPar'.
    -- 
    -- This constructor runs the computation parameter in background. This allows to get parallelism by running multiple computations in background.
    skPar :: a i o -- ^ A function (@i -> o@) or Skeleton (@Skel i o@)
	    -> Skel i (Future o)
    
instance SkParSupport Skel i o where
    skPar = SkPar

instance NFData o => SkParSupport (->) i o where
    skPar = skPar . skSeq

-- | This class allows to use the same function name for create an Stream from a function that returns a Maybe directly or not.
class StGenSupport f i o where
    -- | Smart constructor for 'StGen'. This is the first stage for all Streams.
    --
    -- It takes an initial seed and a generator function that receives a seed and returns a pair with a value and another seed (see the instances). The stream is constructed by sequentially applying the generator function for the initial seed and the next generated seeds until the function returns 'Nothing'.
    stGen :: f -> i -> Stream o

instance NFData o => StGenSupport (i -> (Maybe (o, i))) i o where
    stGen = StGen

instance NFData o => StGenSupport (i -> (o, i)) i o where
    stGen f = StGen (Just . f)


{- ================================================================== -}
{- ======================= Execution Context ======================== -}
{- ================================================================== -}

class ExecutionContext ec m | m -> ec where
    exec :: ec -> Skel i o -> i -> m o


{- ================================================================== -}
{- ========================= Util Functions ========================= -}
{- ================================================================== -}

-- | Creates a Stream from a List. Requires 'NFData' of elements in order to fully evaluates the values.
stFromList :: (NFData a) => [a] -> Stream a
stFromList l = StGen go l
    where
        go [] = Nothing
        go (x:xs) = Just (x, xs)


-- | Analogue to the 'Prelude.const' function but inside of Skeleton DSL. Returns a constant Skeleton that ignores the input and returns the parameter for all input.
skConst :: o -- ^ The constant value returned by the Skeleton.
    -> Skel i o
skConst o = SkSeq_ (\_ -> o)

-- | This function allows to await for a future value and then execute another Skeleton, but without blocking the caller.
-- 
-- The block for the result and the apply of the other Skeleton will be done all in background.
skMapF :: (NFData o) => Skel i o -> Skel (Future i) (Future o)
skMapF sk = skPar $ sk . skSync

-- | This functions transform a pair of Future in a Future of pair.
skPairF :: Skel (Future o1, Future o2) (Future (o1, o2))
skPairF = skPar $ (***) skSync skSync

-- | This function allow transform a 'Traversable' structure of Future in a Future of the structure.
-- 
-- For example, using lists will it transforms a @[Future o]@ in a @Future [o]@.
skTraverseF :: (Traversable t) => Skel (t (Future o)) (Future (t o))
skTraverseF = skPar $ skMap skSync

-- | A complex Skeleton composition example.
-- 
-- This is a Skeleton for the Divide & Conquer pattern. It takes an Skeleton that solves the base problem, a function that say if the input is the base case, and a split and merge functions and gives an Skeleton that applies the Divide & Conquer pattern.
skDaC :: (Traversable t) => 
    Skel i o -- ^ Skeleton that resolves the base case.
    -> (i -> Bool) -- ^ A function that say if the input is the base case.
    -> (i -> t i) -- ^ A divide function strategy.
    -> (i -> t o -> o) -- ^ A merge function strategy.
    -> Skel i o -- ^ A Skeleton that applies the D&C pattern.
skDaC skel isTrivial split combine = proc i -> do
    if (isTrivial i) 
        then
            skel -< i
        else do
            oSplit <- skMap skSync . skMap (skPar (skDaC skel isTrivial split combine)) -< split i
            returnA -< combine i oSplit

